// Generated by tmpl
// https://github.com/benbjohnson/tmpl
//
// DO NOT EDIT!
// Source: vector_values.gen.go.tmpl

package arrowutil

import (
	"fmt"
	"regexp"

	"github.com/influxdata/flux"
	"github.com/influxdata/flux/array"
	"github.com/influxdata/flux/memory"
	"github.com/influxdata/flux/semantic"
	"github.com/influxdata/flux/values"
)

func NewVectorValue(arr array.Interface, typ flux.ColType) values.Vector {
	switch elemType := flux.SemanticType(typ); elemType {

	case semantic.BasicInt:
		return NewIntVectorValue(arr.(*array.Int))

	case semantic.BasicUint:
		return NewUintVectorValue(arr.(*array.Uint))

	case semantic.BasicFloat:
		return NewFloatVectorValue(arr.(*array.Float))

	case semantic.BasicBool:
		return NewBooleanVectorValue(arr.(*array.Boolean))

	case semantic.BasicString:
		return NewStringVectorValue(arr.(*array.String))

	default:
		panic(fmt.Errorf("unsupported column data type: %s", typ))
	}
}

// A convenience method for unit testing
func NewVectorFromElements(mem *memory.Allocator, es ...interface{}) values.Vector {
	var typ flux.ColType
	switch es[0].(type) {

	case int64:
		typ = flux.TInt

	case uint64:
		typ = flux.TUInt

	case float64:
		typ = flux.TFloat

	case bool:
		typ = flux.TBool

	case string:
		typ = flux.TString

	default:
		panic(fmt.Errorf("unsupported data type"))
	}

	vs := make([]values.Value, len(es))
	for i, e := range es {
		vs[i] = values.New(e)
	}
	return newVectorFromSlice(vs, typ, mem)
}

func newVectorFromSlice(values []values.Value, typ flux.ColType, mem *memory.Allocator) values.Vector {
	switch elemType := flux.SemanticType(typ); elemType {

	case semantic.BasicInt:
		b := array.NewIntBuilder(mem)
		for _, v := range values {
			b.Append(v.Int())
		}
		arr := b.NewIntArray()
		return NewIntVectorValue(arr)

	case semantic.BasicUint:
		b := array.NewUintBuilder(mem)
		for _, v := range values {
			b.Append(v.UInt())
		}
		arr := b.NewUintArray()
		return NewUintVectorValue(arr)

	case semantic.BasicFloat:
		b := array.NewFloatBuilder(mem)
		for _, v := range values {
			b.Append(v.Float())
		}
		arr := b.NewFloatArray()
		return NewFloatVectorValue(arr)

	case semantic.BasicBool:
		b := array.NewBooleanBuilder(mem)
		for _, v := range values {
			b.Append(v.Bool())
		}
		arr := b.NewBooleanArray()
		return NewBooleanVectorValue(arr)

	case semantic.BasicString:
		b := array.NewStringBuilder(mem)
		for _, v := range values {
			b.Append(v.Str())
		}
		arr := b.NewStringArray()
		return NewStringVectorValue(arr)

	default:
		panic(fmt.Errorf("unsupported column data type: %s", typ))
	}
}

var _ values.Value = &IntVectorValue{}
var _ values.Vector = &IntVectorValue{}
var _ array.Interface = &array.Int{}

type IntVectorValue struct {
	arr *array.Int
	typ semantic.MonoType
}

func NewIntVectorValue(arr *array.Int) values.Vector {
	return &IntVectorValue{
		arr: arr,
		typ: semantic.NewVectorType(semantic.BasicInt),
	}
}

func (v *IntVectorValue) ElementType() semantic.MonoType {
	t, err := v.typ.ElemType()
	if err != nil {
		panic("could not get element type of vector value")
	}
	return t
}
func (v *IntVectorValue) Arr() array.Interface { return v.arr }
func (v *IntVectorValue) Retain() {
	v.arr.Retain()
}
func (v *IntVectorValue) Release() {
	v.arr.Release()
}

func (v *IntVectorValue) Type() semantic.MonoType { return v.typ }
func (v *IntVectorValue) IsNull() bool            { return false }
func (v *IntVectorValue) Str() string             { panic(values.UnexpectedKind(semantic.Vector, semantic.String)) }
func (v *IntVectorValue) Bytes() []byte {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Bytes))
}
func (v *IntVectorValue) Int() int64   { panic(values.UnexpectedKind(semantic.Vector, semantic.Int)) }
func (v *IntVectorValue) UInt() uint64 { panic(values.UnexpectedKind(semantic.Vector, semantic.UInt)) }
func (v *IntVectorValue) Float() float64 {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Float))
}
func (v *IntVectorValue) Bool() bool { panic(values.UnexpectedKind(semantic.Vector, semantic.Bool)) }
func (v *IntVectorValue) Time() values.Time {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Time))
}
func (v *IntVectorValue) Duration() values.Duration {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Duration))
}
func (v *IntVectorValue) Regexp() *regexp.Regexp {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Regexp))
}
func (v *IntVectorValue) Array() values.Array {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Array))
}
func (v *IntVectorValue) Object() values.Object {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Object))
}
func (v *IntVectorValue) Function() values.Function {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Function))
}
func (v *IntVectorValue) Dict() values.Dictionary {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Dictionary))
}

func (v *IntVectorValue) Equal(other values.Value) bool {
	panic("cannot compare two vectors for equality")
}

var _ values.Value = &UintVectorValue{}
var _ values.Vector = &UintVectorValue{}
var _ array.Interface = &array.Uint{}

type UintVectorValue struct {
	arr *array.Uint
	typ semantic.MonoType
}

func NewUintVectorValue(arr *array.Uint) values.Vector {
	return &UintVectorValue{
		arr: arr,
		typ: semantic.NewVectorType(semantic.BasicUint),
	}
}

func (v *UintVectorValue) ElementType() semantic.MonoType {
	t, err := v.typ.ElemType()
	if err != nil {
		panic("could not get element type of vector value")
	}
	return t
}
func (v *UintVectorValue) Arr() array.Interface { return v.arr }
func (v *UintVectorValue) Retain() {
	v.arr.Retain()
}
func (v *UintVectorValue) Release() {
	v.arr.Release()
}

func (v *UintVectorValue) Type() semantic.MonoType { return v.typ }
func (v *UintVectorValue) IsNull() bool            { return false }
func (v *UintVectorValue) Str() string {
	panic(values.UnexpectedKind(semantic.Vector, semantic.String))
}
func (v *UintVectorValue) Bytes() []byte {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Bytes))
}
func (v *UintVectorValue) Int() int64   { panic(values.UnexpectedKind(semantic.Vector, semantic.Int)) }
func (v *UintVectorValue) UInt() uint64 { panic(values.UnexpectedKind(semantic.Vector, semantic.UInt)) }
func (v *UintVectorValue) Float() float64 {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Float))
}
func (v *UintVectorValue) Bool() bool { panic(values.UnexpectedKind(semantic.Vector, semantic.Bool)) }
func (v *UintVectorValue) Time() values.Time {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Time))
}
func (v *UintVectorValue) Duration() values.Duration {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Duration))
}
func (v *UintVectorValue) Regexp() *regexp.Regexp {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Regexp))
}
func (v *UintVectorValue) Array() values.Array {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Array))
}
func (v *UintVectorValue) Object() values.Object {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Object))
}
func (v *UintVectorValue) Function() values.Function {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Function))
}
func (v *UintVectorValue) Dict() values.Dictionary {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Dictionary))
}

func (v *UintVectorValue) Equal(other values.Value) bool {
	panic("cannot compare two vectors for equality")
}

var _ values.Value = &FloatVectorValue{}
var _ values.Vector = &FloatVectorValue{}
var _ array.Interface = &array.Float{}

type FloatVectorValue struct {
	arr *array.Float
	typ semantic.MonoType
}

func NewFloatVectorValue(arr *array.Float) values.Vector {
	return &FloatVectorValue{
		arr: arr,
		typ: semantic.NewVectorType(semantic.BasicFloat),
	}
}

func (v *FloatVectorValue) ElementType() semantic.MonoType {
	t, err := v.typ.ElemType()
	if err != nil {
		panic("could not get element type of vector value")
	}
	return t
}
func (v *FloatVectorValue) Arr() array.Interface { return v.arr }
func (v *FloatVectorValue) Retain() {
	v.arr.Retain()
}
func (v *FloatVectorValue) Release() {
	v.arr.Release()
}

func (v *FloatVectorValue) Type() semantic.MonoType { return v.typ }
func (v *FloatVectorValue) IsNull() bool            { return false }
func (v *FloatVectorValue) Str() string {
	panic(values.UnexpectedKind(semantic.Vector, semantic.String))
}
func (v *FloatVectorValue) Bytes() []byte {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Bytes))
}
func (v *FloatVectorValue) Int() int64 { panic(values.UnexpectedKind(semantic.Vector, semantic.Int)) }
func (v *FloatVectorValue) UInt() uint64 {
	panic(values.UnexpectedKind(semantic.Vector, semantic.UInt))
}
func (v *FloatVectorValue) Float() float64 {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Float))
}
func (v *FloatVectorValue) Bool() bool { panic(values.UnexpectedKind(semantic.Vector, semantic.Bool)) }
func (v *FloatVectorValue) Time() values.Time {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Time))
}
func (v *FloatVectorValue) Duration() values.Duration {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Duration))
}
func (v *FloatVectorValue) Regexp() *regexp.Regexp {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Regexp))
}
func (v *FloatVectorValue) Array() values.Array {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Array))
}
func (v *FloatVectorValue) Object() values.Object {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Object))
}
func (v *FloatVectorValue) Function() values.Function {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Function))
}
func (v *FloatVectorValue) Dict() values.Dictionary {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Dictionary))
}

func (v *FloatVectorValue) Equal(other values.Value) bool {
	panic("cannot compare two vectors for equality")
}

var _ values.Value = &BooleanVectorValue{}
var _ values.Vector = &BooleanVectorValue{}
var _ array.Interface = &array.Boolean{}

type BooleanVectorValue struct {
	arr *array.Boolean
	typ semantic.MonoType
}

func NewBooleanVectorValue(arr *array.Boolean) values.Vector {
	return &BooleanVectorValue{
		arr: arr,
		typ: semantic.NewVectorType(semantic.BasicBool),
	}
}

func (v *BooleanVectorValue) ElementType() semantic.MonoType {
	t, err := v.typ.ElemType()
	if err != nil {
		panic("could not get element type of vector value")
	}
	return t
}
func (v *BooleanVectorValue) Arr() array.Interface { return v.arr }
func (v *BooleanVectorValue) Retain() {
	v.arr.Retain()
}
func (v *BooleanVectorValue) Release() {
	v.arr.Release()
}

func (v *BooleanVectorValue) Type() semantic.MonoType { return v.typ }
func (v *BooleanVectorValue) IsNull() bool            { return false }
func (v *BooleanVectorValue) Str() string {
	panic(values.UnexpectedKind(semantic.Vector, semantic.String))
}
func (v *BooleanVectorValue) Bytes() []byte {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Bytes))
}
func (v *BooleanVectorValue) Int() int64 { panic(values.UnexpectedKind(semantic.Vector, semantic.Int)) }
func (v *BooleanVectorValue) UInt() uint64 {
	panic(values.UnexpectedKind(semantic.Vector, semantic.UInt))
}
func (v *BooleanVectorValue) Float() float64 {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Float))
}
func (v *BooleanVectorValue) Bool() bool {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Bool))
}
func (v *BooleanVectorValue) Time() values.Time {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Time))
}
func (v *BooleanVectorValue) Duration() values.Duration {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Duration))
}
func (v *BooleanVectorValue) Regexp() *regexp.Regexp {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Regexp))
}
func (v *BooleanVectorValue) Array() values.Array {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Array))
}
func (v *BooleanVectorValue) Object() values.Object {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Object))
}
func (v *BooleanVectorValue) Function() values.Function {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Function))
}
func (v *BooleanVectorValue) Dict() values.Dictionary {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Dictionary))
}

func (v *BooleanVectorValue) Equal(other values.Value) bool {
	panic("cannot compare two vectors for equality")
}

var _ values.Value = &StringVectorValue{}
var _ values.Vector = &StringVectorValue{}
var _ array.Interface = &array.String{}

type StringVectorValue struct {
	arr *array.String
	typ semantic.MonoType
}

func NewStringVectorValue(arr *array.String) values.Vector {
	return &StringVectorValue{
		arr: arr,
		typ: semantic.NewVectorType(semantic.BasicString),
	}
}

func (v *StringVectorValue) ElementType() semantic.MonoType {
	t, err := v.typ.ElemType()
	if err != nil {
		panic("could not get element type of vector value")
	}
	return t
}
func (v *StringVectorValue) Arr() array.Interface { return v.arr }
func (v *StringVectorValue) Retain() {
	v.arr.Retain()
}
func (v *StringVectorValue) Release() {
	v.arr.Release()
}

func (v *StringVectorValue) Type() semantic.MonoType { return v.typ }
func (v *StringVectorValue) IsNull() bool            { return false }
func (v *StringVectorValue) Str() string {
	panic(values.UnexpectedKind(semantic.Vector, semantic.String))
}
func (v *StringVectorValue) Bytes() []byte {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Bytes))
}
func (v *StringVectorValue) Int() int64 { panic(values.UnexpectedKind(semantic.Vector, semantic.Int)) }
func (v *StringVectorValue) UInt() uint64 {
	panic(values.UnexpectedKind(semantic.Vector, semantic.UInt))
}
func (v *StringVectorValue) Float() float64 {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Float))
}
func (v *StringVectorValue) Bool() bool { panic(values.UnexpectedKind(semantic.Vector, semantic.Bool)) }
func (v *StringVectorValue) Time() values.Time {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Time))
}
func (v *StringVectorValue) Duration() values.Duration {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Duration))
}
func (v *StringVectorValue) Regexp() *regexp.Regexp {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Regexp))
}
func (v *StringVectorValue) Array() values.Array {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Array))
}
func (v *StringVectorValue) Object() values.Object {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Object))
}
func (v *StringVectorValue) Function() values.Function {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Function))
}
func (v *StringVectorValue) Dict() values.Dictionary {
	panic(values.UnexpectedKind(semantic.Vector, semantic.Dictionary))
}

func (v *StringVectorValue) Equal(other values.Value) bool {
	panic("cannot compare two vectors for equality")
}
