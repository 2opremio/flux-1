// Generated by tmpl
// https://github.com/benbjohnson/tmpl
//
// DO NOT EDIT!
// Source: binary.gen.go.tmpl

package compiler

import (
	"context"

	"github.com/influxdata/flux/codes"
	"github.com/influxdata/flux/internal/errors"
	"github.com/influxdata/flux/semantic"
)

func newEqualsEvaluator(ret, left, right int, ltyp, rtyp semantic.MonoType) (Evaluator, error) {
	switch ltyp.Nature() {

	case semantic.Int:
		switch rtyp.Nature() {
		case semantic.Int:
			return &intEqualsEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		case semantic.UInt:
			return &intUintEqualsEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		case semantic.Float:
			return &intFloatEqualsEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		}

	case semantic.UInt:
		switch rtyp.Nature() {
		case semantic.UInt:
			return &uintEqualsEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		case semantic.Int:
			return &uintIntEqualsEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		case semantic.Float:
			return &uintFloatEqualsEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		}

	case semantic.Float:
		switch rtyp.Nature() {
		case semantic.Float:
			return &floatEqualsEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		case semantic.Int:
			return &floatIntEqualsEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		case semantic.UInt:
			return &floatUintEqualsEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		}

	case semantic.String:
		switch rtyp.Nature() {
		case semantic.String:
			return &stringEqualsEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		}

	case semantic.Bool:
		switch rtyp.Nature() {
		case semantic.Bool:
			return &boolEqualsEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		}

	case semantic.Time:
		switch rtyp.Nature() {
		case semantic.Time:
			return &timeEqualsEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		}

	}
	return nil, errors.Newf(codes.Invalid, "unsupported binary expression %v == %v", ltyp.Nature(), rtyp.Nature())
}

type intEqualsEvaluator struct {
	evaluator
	left, right int
}

func (e *intEqualsEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}
	scope[e.ret] = NewBool(lv.Int() == rv.Int())
	return nil
}

type intUintEqualsEvaluator struct {
	evaluator
	left, right int
}

func (e *intUintEqualsEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}

	scope[e.ret] = NewBool(uint64(lv.Int()) == rv.Uint())

	return nil
}

type intFloatEqualsEvaluator struct {
	evaluator
	left, right int
}

func (e *intFloatEqualsEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}

	scope[e.ret] = NewBool(float64(lv.Int()) == rv.Float())

	return nil
}

type uintEqualsEvaluator struct {
	evaluator
	left, right int
}

func (e *uintEqualsEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}
	scope[e.ret] = NewBool(lv.Uint() == rv.Uint())
	return nil
}

type uintIntEqualsEvaluator struct {
	evaluator
	left, right int
}

func (e *uintIntEqualsEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}

	scope[e.ret] = NewBool(lv.Uint() == uint64(rv.Int()))

	return nil
}

type uintFloatEqualsEvaluator struct {
	evaluator
	left, right int
}

func (e *uintFloatEqualsEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}

	scope[e.ret] = NewBool(float64(lv.Uint()) == rv.Float())

	return nil
}

type floatEqualsEvaluator struct {
	evaluator
	left, right int
}

func (e *floatEqualsEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}
	scope[e.ret] = NewBool(lv.Float() == rv.Float())
	return nil
}

type floatIntEqualsEvaluator struct {
	evaluator
	left, right int
}

func (e *floatIntEqualsEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}

	scope[e.ret] = NewBool(lv.Float() == float64(rv.Int()))

	return nil
}

type floatUintEqualsEvaluator struct {
	evaluator
	left, right int
}

func (e *floatUintEqualsEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}

	scope[e.ret] = NewBool(lv.Float() == float64(rv.Uint()))

	return nil
}

type stringEqualsEvaluator struct {
	evaluator
	left, right int
}

func (e *stringEqualsEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}
	scope[e.ret] = NewBool(lv.Str() == rv.Str())
	return nil
}

type boolEqualsEvaluator struct {
	evaluator
	left, right int
}

func (e *boolEqualsEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}
	scope[e.ret] = NewBool(lv.Bool() == rv.Bool())
	return nil
}

type timeEqualsEvaluator struct {
	evaluator
	left, right int
}

func (e *timeEqualsEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}
	scope[e.ret] = NewBool(lv.Time() == rv.Time())
	return nil
}

func newNotEqualsEvaluator(ret, left, right int, ltyp, rtyp semantic.MonoType) (Evaluator, error) {
	switch ltyp.Nature() {

	case semantic.Int:
		switch rtyp.Nature() {
		case semantic.Int:
			return &intNotEqualsEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		case semantic.UInt:
			return &intUintNotEqualsEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		case semantic.Float:
			return &intFloatNotEqualsEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		}

	case semantic.UInt:
		switch rtyp.Nature() {
		case semantic.UInt:
			return &uintNotEqualsEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		case semantic.Int:
			return &uintIntNotEqualsEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		case semantic.Float:
			return &uintFloatNotEqualsEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		}

	case semantic.Float:
		switch rtyp.Nature() {
		case semantic.Float:
			return &floatNotEqualsEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		case semantic.Int:
			return &floatIntNotEqualsEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		case semantic.UInt:
			return &floatUintNotEqualsEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		}

	case semantic.String:
		switch rtyp.Nature() {
		case semantic.String:
			return &stringNotEqualsEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		}

	case semantic.Bool:
		switch rtyp.Nature() {
		case semantic.Bool:
			return &boolNotEqualsEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		}

	case semantic.Time:
		switch rtyp.Nature() {
		case semantic.Time:
			return &timeNotEqualsEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		}

	}
	return nil, errors.Newf(codes.Invalid, "unsupported binary expression %v != %v", ltyp.Nature(), rtyp.Nature())
}

type intNotEqualsEvaluator struct {
	evaluator
	left, right int
}

func (e *intNotEqualsEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}
	scope[e.ret] = NewBool(lv.Int() != rv.Int())
	return nil
}

type intUintNotEqualsEvaluator struct {
	evaluator
	left, right int
}

func (e *intUintNotEqualsEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}

	scope[e.ret] = NewBool(uint64(lv.Int()) != rv.Uint())

	return nil
}

type intFloatNotEqualsEvaluator struct {
	evaluator
	left, right int
}

func (e *intFloatNotEqualsEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}

	scope[e.ret] = NewBool(float64(lv.Int()) != rv.Float())

	return nil
}

type uintNotEqualsEvaluator struct {
	evaluator
	left, right int
}

func (e *uintNotEqualsEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}
	scope[e.ret] = NewBool(lv.Uint() != rv.Uint())
	return nil
}

type uintIntNotEqualsEvaluator struct {
	evaluator
	left, right int
}

func (e *uintIntNotEqualsEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}

	scope[e.ret] = NewBool(lv.Uint() != uint64(rv.Int()))

	return nil
}

type uintFloatNotEqualsEvaluator struct {
	evaluator
	left, right int
}

func (e *uintFloatNotEqualsEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}

	scope[e.ret] = NewBool(float64(lv.Uint()) != rv.Float())

	return nil
}

type floatNotEqualsEvaluator struct {
	evaluator
	left, right int
}

func (e *floatNotEqualsEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}
	scope[e.ret] = NewBool(lv.Float() != rv.Float())
	return nil
}

type floatIntNotEqualsEvaluator struct {
	evaluator
	left, right int
}

func (e *floatIntNotEqualsEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}

	scope[e.ret] = NewBool(lv.Float() != float64(rv.Int()))

	return nil
}

type floatUintNotEqualsEvaluator struct {
	evaluator
	left, right int
}

func (e *floatUintNotEqualsEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}

	scope[e.ret] = NewBool(lv.Float() != float64(rv.Uint()))

	return nil
}

type stringNotEqualsEvaluator struct {
	evaluator
	left, right int
}

func (e *stringNotEqualsEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}
	scope[e.ret] = NewBool(lv.Str() != rv.Str())
	return nil
}

type boolNotEqualsEvaluator struct {
	evaluator
	left, right int
}

func (e *boolNotEqualsEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}
	scope[e.ret] = NewBool(lv.Bool() != rv.Bool())
	return nil
}

type timeNotEqualsEvaluator struct {
	evaluator
	left, right int
}

func (e *timeNotEqualsEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}
	scope[e.ret] = NewBool(lv.Time() != rv.Time())
	return nil
}

func newLessThanEvaluator(ret, left, right int, ltyp, rtyp semantic.MonoType) (Evaluator, error) {
	switch ltyp.Nature() {

	case semantic.Int:
		switch rtyp.Nature() {
		case semantic.Int:
			return &intLessThanEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		case semantic.UInt:
			return &intUintLessThanEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		case semantic.Float:
			return &intFloatLessThanEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		}

	case semantic.UInt:
		switch rtyp.Nature() {
		case semantic.UInt:
			return &uintLessThanEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		case semantic.Int:
			return &uintIntLessThanEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		case semantic.Float:
			return &uintFloatLessThanEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		}

	case semantic.Float:
		switch rtyp.Nature() {
		case semantic.Float:
			return &floatLessThanEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		case semantic.Int:
			return &floatIntLessThanEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		case semantic.UInt:
			return &floatUintLessThanEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		}

	case semantic.String:
		switch rtyp.Nature() {
		case semantic.String:
			return &stringLessThanEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		}

	case semantic.Time:
		switch rtyp.Nature() {
		case semantic.Time:
			return &timeLessThanEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		}

	}
	return nil, errors.Newf(codes.Invalid, "unsupported binary expression %v < %v", ltyp.Nature(), rtyp.Nature())
}

type intLessThanEvaluator struct {
	evaluator
	left, right int
}

func (e *intLessThanEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}
	scope[e.ret] = NewBool(lv.Int() < rv.Int())
	return nil
}

type intUintLessThanEvaluator struct {
	evaluator
	left, right int
}

func (e *intUintLessThanEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}

	scope[e.ret] = NewBool(uint64(lv.Int()) < rv.Uint())

	return nil
}

type intFloatLessThanEvaluator struct {
	evaluator
	left, right int
}

func (e *intFloatLessThanEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}

	scope[e.ret] = NewBool(float64(lv.Int()) < rv.Float())

	return nil
}

type uintLessThanEvaluator struct {
	evaluator
	left, right int
}

func (e *uintLessThanEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}
	scope[e.ret] = NewBool(lv.Uint() < rv.Uint())
	return nil
}

type uintIntLessThanEvaluator struct {
	evaluator
	left, right int
}

func (e *uintIntLessThanEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}

	scope[e.ret] = NewBool(lv.Uint() < uint64(rv.Int()))

	return nil
}

type uintFloatLessThanEvaluator struct {
	evaluator
	left, right int
}

func (e *uintFloatLessThanEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}

	scope[e.ret] = NewBool(float64(lv.Uint()) < rv.Float())

	return nil
}

type floatLessThanEvaluator struct {
	evaluator
	left, right int
}

func (e *floatLessThanEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}
	scope[e.ret] = NewBool(lv.Float() < rv.Float())
	return nil
}

type floatIntLessThanEvaluator struct {
	evaluator
	left, right int
}

func (e *floatIntLessThanEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}

	scope[e.ret] = NewBool(lv.Float() < float64(rv.Int()))

	return nil
}

type floatUintLessThanEvaluator struct {
	evaluator
	left, right int
}

func (e *floatUintLessThanEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}

	scope[e.ret] = NewBool(lv.Float() < float64(rv.Uint()))

	return nil
}

type stringLessThanEvaluator struct {
	evaluator
	left, right int
}

func (e *stringLessThanEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}
	scope[e.ret] = NewBool(lv.Str() < rv.Str())
	return nil
}

type timeLessThanEvaluator struct {
	evaluator
	left, right int
}

func (e *timeLessThanEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}
	scope[e.ret] = NewBool(lv.Time() < rv.Time())
	return nil
}

func newGreaterThanEvaluator(ret, left, right int, ltyp, rtyp semantic.MonoType) (Evaluator, error) {
	switch ltyp.Nature() {

	case semantic.Int:
		switch rtyp.Nature() {
		case semantic.Int:
			return &intGreaterThanEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		case semantic.UInt:
			return &intUintGreaterThanEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		case semantic.Float:
			return &intFloatGreaterThanEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		}

	case semantic.UInt:
		switch rtyp.Nature() {
		case semantic.UInt:
			return &uintGreaterThanEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		case semantic.Int:
			return &uintIntGreaterThanEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		case semantic.Float:
			return &uintFloatGreaterThanEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		}

	case semantic.Float:
		switch rtyp.Nature() {
		case semantic.Float:
			return &floatGreaterThanEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		case semantic.Int:
			return &floatIntGreaterThanEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		case semantic.UInt:
			return &floatUintGreaterThanEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		}

	case semantic.String:
		switch rtyp.Nature() {
		case semantic.String:
			return &stringGreaterThanEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		}

	case semantic.Time:
		switch rtyp.Nature() {
		case semantic.Time:
			return &timeGreaterThanEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		}

	}
	return nil, errors.Newf(codes.Invalid, "unsupported binary expression %v > %v", ltyp.Nature(), rtyp.Nature())
}

type intGreaterThanEvaluator struct {
	evaluator
	left, right int
}

func (e *intGreaterThanEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}
	scope[e.ret] = NewBool(lv.Int() > rv.Int())
	return nil
}

type intUintGreaterThanEvaluator struct {
	evaluator
	left, right int
}

func (e *intUintGreaterThanEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}

	scope[e.ret] = NewBool(uint64(lv.Int()) > rv.Uint())

	return nil
}

type intFloatGreaterThanEvaluator struct {
	evaluator
	left, right int
}

func (e *intFloatGreaterThanEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}

	scope[e.ret] = NewBool(float64(lv.Int()) > rv.Float())

	return nil
}

type uintGreaterThanEvaluator struct {
	evaluator
	left, right int
}

func (e *uintGreaterThanEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}
	scope[e.ret] = NewBool(lv.Uint() > rv.Uint())
	return nil
}

type uintIntGreaterThanEvaluator struct {
	evaluator
	left, right int
}

func (e *uintIntGreaterThanEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}

	scope[e.ret] = NewBool(lv.Uint() > uint64(rv.Int()))

	return nil
}

type uintFloatGreaterThanEvaluator struct {
	evaluator
	left, right int
}

func (e *uintFloatGreaterThanEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}

	scope[e.ret] = NewBool(float64(lv.Uint()) > rv.Float())

	return nil
}

type floatGreaterThanEvaluator struct {
	evaluator
	left, right int
}

func (e *floatGreaterThanEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}
	scope[e.ret] = NewBool(lv.Float() > rv.Float())
	return nil
}

type floatIntGreaterThanEvaluator struct {
	evaluator
	left, right int
}

func (e *floatIntGreaterThanEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}

	scope[e.ret] = NewBool(lv.Float() > float64(rv.Int()))

	return nil
}

type floatUintGreaterThanEvaluator struct {
	evaluator
	left, right int
}

func (e *floatUintGreaterThanEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}

	scope[e.ret] = NewBool(lv.Float() > float64(rv.Uint()))

	return nil
}

type stringGreaterThanEvaluator struct {
	evaluator
	left, right int
}

func (e *stringGreaterThanEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}
	scope[e.ret] = NewBool(lv.Str() > rv.Str())
	return nil
}

type timeGreaterThanEvaluator struct {
	evaluator
	left, right int
}

func (e *timeGreaterThanEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}
	scope[e.ret] = NewBool(lv.Time() > rv.Time())
	return nil
}

func newLessThanEqualEvaluator(ret, left, right int, ltyp, rtyp semantic.MonoType) (Evaluator, error) {
	switch ltyp.Nature() {

	case semantic.Int:
		switch rtyp.Nature() {
		case semantic.Int:
			return &intLessThanEqualEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		case semantic.UInt:
			return &intUintLessThanEqualEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		case semantic.Float:
			return &intFloatLessThanEqualEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		}

	case semantic.UInt:
		switch rtyp.Nature() {
		case semantic.UInt:
			return &uintLessThanEqualEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		case semantic.Int:
			return &uintIntLessThanEqualEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		case semantic.Float:
			return &uintFloatLessThanEqualEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		}

	case semantic.Float:
		switch rtyp.Nature() {
		case semantic.Float:
			return &floatLessThanEqualEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		case semantic.Int:
			return &floatIntLessThanEqualEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		case semantic.UInt:
			return &floatUintLessThanEqualEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		}

	case semantic.String:
		switch rtyp.Nature() {
		case semantic.String:
			return &stringLessThanEqualEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		}

	case semantic.Time:
		switch rtyp.Nature() {
		case semantic.Time:
			return &timeLessThanEqualEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		}

	}
	return nil, errors.Newf(codes.Invalid, "unsupported binary expression %v <= %v", ltyp.Nature(), rtyp.Nature())
}

type intLessThanEqualEvaluator struct {
	evaluator
	left, right int
}

func (e *intLessThanEqualEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}
	scope[e.ret] = NewBool(lv.Int() <= rv.Int())
	return nil
}

type intUintLessThanEqualEvaluator struct {
	evaluator
	left, right int
}

func (e *intUintLessThanEqualEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}

	scope[e.ret] = NewBool(uint64(lv.Int()) <= rv.Uint())

	return nil
}

type intFloatLessThanEqualEvaluator struct {
	evaluator
	left, right int
}

func (e *intFloatLessThanEqualEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}

	scope[e.ret] = NewBool(float64(lv.Int()) <= rv.Float())

	return nil
}

type uintLessThanEqualEvaluator struct {
	evaluator
	left, right int
}

func (e *uintLessThanEqualEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}
	scope[e.ret] = NewBool(lv.Uint() <= rv.Uint())
	return nil
}

type uintIntLessThanEqualEvaluator struct {
	evaluator
	left, right int
}

func (e *uintIntLessThanEqualEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}

	scope[e.ret] = NewBool(lv.Uint() <= uint64(rv.Int()))

	return nil
}

type uintFloatLessThanEqualEvaluator struct {
	evaluator
	left, right int
}

func (e *uintFloatLessThanEqualEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}

	scope[e.ret] = NewBool(float64(lv.Uint()) <= rv.Float())

	return nil
}

type floatLessThanEqualEvaluator struct {
	evaluator
	left, right int
}

func (e *floatLessThanEqualEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}
	scope[e.ret] = NewBool(lv.Float() <= rv.Float())
	return nil
}

type floatIntLessThanEqualEvaluator struct {
	evaluator
	left, right int
}

func (e *floatIntLessThanEqualEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}

	scope[e.ret] = NewBool(lv.Float() <= float64(rv.Int()))

	return nil
}

type floatUintLessThanEqualEvaluator struct {
	evaluator
	left, right int
}

func (e *floatUintLessThanEqualEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}

	scope[e.ret] = NewBool(lv.Float() <= float64(rv.Uint()))

	return nil
}

type stringLessThanEqualEvaluator struct {
	evaluator
	left, right int
}

func (e *stringLessThanEqualEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}
	scope[e.ret] = NewBool(lv.Str() <= rv.Str())
	return nil
}

type timeLessThanEqualEvaluator struct {
	evaluator
	left, right int
}

func (e *timeLessThanEqualEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}
	scope[e.ret] = NewBool(lv.Time() <= rv.Time())
	return nil
}

func newGreaterThanEqualEvaluator(ret, left, right int, ltyp, rtyp semantic.MonoType) (Evaluator, error) {
	switch ltyp.Nature() {

	case semantic.Int:
		switch rtyp.Nature() {
		case semantic.Int:
			return &intGreaterThanEqualEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		case semantic.UInt:
			return &intUintGreaterThanEqualEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		case semantic.Float:
			return &intFloatGreaterThanEqualEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		}

	case semantic.UInt:
		switch rtyp.Nature() {
		case semantic.UInt:
			return &uintGreaterThanEqualEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		case semantic.Int:
			return &uintIntGreaterThanEqualEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		case semantic.Float:
			return &uintFloatGreaterThanEqualEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		}

	case semantic.Float:
		switch rtyp.Nature() {
		case semantic.Float:
			return &floatGreaterThanEqualEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		case semantic.Int:
			return &floatIntGreaterThanEqualEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		case semantic.UInt:
			return &floatUintGreaterThanEqualEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		}

	case semantic.String:
		switch rtyp.Nature() {
		case semantic.String:
			return &stringGreaterThanEqualEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		}

	case semantic.Time:
		switch rtyp.Nature() {
		case semantic.Time:
			return &timeGreaterThanEqualEvaluator{
				evaluator: evaluator{
					t:   semantic.BasicBool,
					ret: ret,
				},
				left:  left,
				right: right,
			}, nil

		}

	}
	return nil, errors.Newf(codes.Invalid, "unsupported binary expression %v >= %v", ltyp.Nature(), rtyp.Nature())
}

type intGreaterThanEqualEvaluator struct {
	evaluator
	left, right int
}

func (e *intGreaterThanEqualEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}
	scope[e.ret] = NewBool(lv.Int() >= rv.Int())
	return nil
}

type intUintGreaterThanEqualEvaluator struct {
	evaluator
	left, right int
}

func (e *intUintGreaterThanEqualEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}

	scope[e.ret] = NewBool(uint64(lv.Int()) >= rv.Uint())

	return nil
}

type intFloatGreaterThanEqualEvaluator struct {
	evaluator
	left, right int
}

func (e *intFloatGreaterThanEqualEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}

	scope[e.ret] = NewBool(float64(lv.Int()) >= rv.Float())

	return nil
}

type uintGreaterThanEqualEvaluator struct {
	evaluator
	left, right int
}

func (e *uintGreaterThanEqualEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}
	scope[e.ret] = NewBool(lv.Uint() >= rv.Uint())
	return nil
}

type uintIntGreaterThanEqualEvaluator struct {
	evaluator
	left, right int
}

func (e *uintIntGreaterThanEqualEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}

	scope[e.ret] = NewBool(lv.Uint() >= uint64(rv.Int()))

	return nil
}

type uintFloatGreaterThanEqualEvaluator struct {
	evaluator
	left, right int
}

func (e *uintFloatGreaterThanEqualEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}

	scope[e.ret] = NewBool(float64(lv.Uint()) >= rv.Float())

	return nil
}

type floatGreaterThanEqualEvaluator struct {
	evaluator
	left, right int
}

func (e *floatGreaterThanEqualEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}
	scope[e.ret] = NewBool(lv.Float() >= rv.Float())
	return nil
}

type floatIntGreaterThanEqualEvaluator struct {
	evaluator
	left, right int
}

func (e *floatIntGreaterThanEqualEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}

	scope[e.ret] = NewBool(lv.Float() >= float64(rv.Int()))

	return nil
}

type floatUintGreaterThanEqualEvaluator struct {
	evaluator
	left, right int
}

func (e *floatUintGreaterThanEqualEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}

	scope[e.ret] = NewBool(lv.Float() >= float64(rv.Uint()))

	return nil
}

type stringGreaterThanEqualEvaluator struct {
	evaluator
	left, right int
}

func (e *stringGreaterThanEqualEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}
	scope[e.ret] = NewBool(lv.Str() >= rv.Str())
	return nil
}

type timeGreaterThanEqualEvaluator struct {
	evaluator
	left, right int
}

func (e *timeGreaterThanEqualEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}
	scope[e.ret] = NewBool(lv.Time() >= rv.Time())
	return nil
}

func newAddEvaluator(ret, left, right int, typ semantic.MonoType) (Evaluator, error) {
	switch typ.Nature() {

	case semantic.Int:
		return &intAddEvaluator{
			evaluator: evaluator{
				t:   typ,
				ret: ret,
			},
			left:  left,
			right: right,
		}, nil

	case semantic.UInt:
		return &uintAddEvaluator{
			evaluator: evaluator{
				t:   typ,
				ret: ret,
			},
			left:  left,
			right: right,
		}, nil

	case semantic.Float:
		return &floatAddEvaluator{
			evaluator: evaluator{
				t:   typ,
				ret: ret,
			},
			left:  left,
			right: right,
		}, nil

	case semantic.String:
		return &stringAddEvaluator{
			evaluator: evaluator{
				t:   typ,
				ret: ret,
			},
			left:  left,
			right: right,
		}, nil

	}
	return nil, errors.Newf(codes.Invalid, "unsupported binary expression %v + %v", typ.Nature(), typ.Nature())
}

type intAddEvaluator struct {
	evaluator
	left, right int
}

func (e *intAddEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}
	scope[e.ret] = NewInt(lv.Int() + rv.Int())
	return nil
}

type uintAddEvaluator struct {
	evaluator
	left, right int
}

func (e *uintAddEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}
	scope[e.ret] = NewUint(lv.Uint() + rv.Uint())
	return nil
}

type floatAddEvaluator struct {
	evaluator
	left, right int
}

func (e *floatAddEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}
	scope[e.ret] = NewFloat(lv.Float() + rv.Float())
	return nil
}

type stringAddEvaluator struct {
	evaluator
	left, right int
}

func (e *stringAddEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}
	scope[e.ret] = NewString(lv.Str() + rv.Str())
	return nil
}

func newSubtractEvaluator(ret, left, right int, typ semantic.MonoType) (Evaluator, error) {
	switch typ.Nature() {

	case semantic.Int:
		return &intSubtractEvaluator{
			evaluator: evaluator{
				t:   typ,
				ret: ret,
			},
			left:  left,
			right: right,
		}, nil

	case semantic.UInt:
		return &uintSubtractEvaluator{
			evaluator: evaluator{
				t:   typ,
				ret: ret,
			},
			left:  left,
			right: right,
		}, nil

	case semantic.Float:
		return &floatSubtractEvaluator{
			evaluator: evaluator{
				t:   typ,
				ret: ret,
			},
			left:  left,
			right: right,
		}, nil

	}
	return nil, errors.Newf(codes.Invalid, "unsupported binary expression %v + %v", typ.Nature(), typ.Nature())
}

type intSubtractEvaluator struct {
	evaluator
	left, right int
}

func (e *intSubtractEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}
	scope[e.ret] = NewInt(lv.Int() + rv.Int())
	return nil
}

type uintSubtractEvaluator struct {
	evaluator
	left, right int
}

func (e *uintSubtractEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}
	scope[e.ret] = NewUint(lv.Uint() + rv.Uint())
	return nil
}

type floatSubtractEvaluator struct {
	evaluator
	left, right int
}

func (e *floatSubtractEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}
	scope[e.ret] = NewFloat(lv.Float() + rv.Float())
	return nil
}

func newMulEvaluator(ret, left, right int, typ semantic.MonoType) (Evaluator, error) {
	switch typ.Nature() {

	case semantic.Int:
		return &intMulEvaluator{
			evaluator: evaluator{
				t:   typ,
				ret: ret,
			},
			left:  left,
			right: right,
		}, nil

	case semantic.UInt:
		return &uintMulEvaluator{
			evaluator: evaluator{
				t:   typ,
				ret: ret,
			},
			left:  left,
			right: right,
		}, nil

	case semantic.Float:
		return &floatMulEvaluator{
			evaluator: evaluator{
				t:   typ,
				ret: ret,
			},
			left:  left,
			right: right,
		}, nil

	}

	return nil, errors.Newf(codes.Invalid, "unsupported binary expression %v * %v", typ.Nature(), typ.Nature())

}

type intMulEvaluator struct {
	evaluator
	left, right int
}

func (e *intMulEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}

	scope[e.ret] = NewInt(lv.Int() * rv.Int())

	return nil
}

type uintMulEvaluator struct {
	evaluator
	left, right int
}

func (e *uintMulEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}

	scope[e.ret] = NewUint(lv.Uint() * rv.Uint())

	return nil
}

type floatMulEvaluator struct {
	evaluator
	left, right int
}

func (e *floatMulEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}

	scope[e.ret] = NewFloat(lv.Float() * rv.Float())

	return nil
}

func newDivEvaluator(ret, left, right int, typ semantic.MonoType) (Evaluator, error) {
	switch typ.Nature() {

	case semantic.Int:
		return &intDivEvaluator{
			evaluator: evaluator{
				t:   typ,
				ret: ret,
			},
			left:  left,
			right: right,
		}, nil

	case semantic.UInt:
		return &uintDivEvaluator{
			evaluator: evaluator{
				t:   typ,
				ret: ret,
			},
			left:  left,
			right: right,
		}, nil

	case semantic.Float:
		return &floatDivEvaluator{
			evaluator: evaluator{
				t:   typ,
				ret: ret,
			},
			left:  left,
			right: right,
		}, nil

	}

	return nil, errors.Newf(codes.Invalid, "unsupported binary expression %v / %v", typ.Nature(), typ.Nature())

}

type intDivEvaluator struct {
	evaluator
	left, right int
}

func (e *intDivEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}

	scope[e.ret] = NewInt(lv.Int() / rv.Int())

	return nil
}

type uintDivEvaluator struct {
	evaluator
	left, right int
}

func (e *uintDivEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}

	scope[e.ret] = NewUint(lv.Uint() / rv.Uint())

	return nil
}

type floatDivEvaluator struct {
	evaluator
	left, right int
}

func (e *floatDivEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}

	scope[e.ret] = NewFloat(lv.Float() / rv.Float())

	return nil
}

func newModEvaluator(ret, left, right int, typ semantic.MonoType) (Evaluator, error) {
	switch typ.Nature() {

	case semantic.Int:
		return &intModEvaluator{
			evaluator: evaluator{
				t:   typ,
				ret: ret,
			},
			left:  left,
			right: right,
		}, nil

	case semantic.UInt:
		return &uintModEvaluator{
			evaluator: evaluator{
				t:   typ,
				ret: ret,
			},
			left:  left,
			right: right,
		}, nil

	case semantic.Float:
		return &floatModEvaluator{
			evaluator: evaluator{
				t:   typ,
				ret: ret,
			},
			left:  left,
			right: right,
		}, nil

	}

	return nil, errors.Newf(codes.Invalid, "unsupported binary expression %v %% %v", typ.Nature(), typ.Nature())

}

type intModEvaluator struct {
	evaluator
	left, right int
}

func (e *intModEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}

	scope[e.ret] = NewInt(modInt(lv.Int(), rv.Int()))

	return nil
}

type uintModEvaluator struct {
	evaluator
	left, right int
}

func (e *uintModEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}

	scope[e.ret] = NewUint(modUint(lv.Uint(), rv.Uint()))

	return nil
}

type floatModEvaluator struct {
	evaluator
	left, right int
}

func (e *floatModEvaluator) Eval(ctx context.Context, scope []Value, origin int) error {
	lv, rv := scope[e.left], scope[e.right]
	if lv.IsNull() || rv.IsNull() {
		scope[e.ret] = Value{}
		return nil
	}

	scope[e.ret] = NewFloat(modFloat(lv.Float(), rv.Float()))

	return nil
}
