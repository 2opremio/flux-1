// DO NOT EDIT: This file is autogenerated via the builtin command.

package interval

import (
	ast "github.com/influxdata/flux/ast"
	parser "github.com/influxdata/flux/internal/parser"
)

var FluxTestPackages = []*ast.Package{&ast.Package{
	BaseNode: ast.BaseNode{
		Errors: nil,
		Loc:    nil,
	},
	Files: []*ast.File{&ast.File{
		BaseNode: ast.BaseNode{
			Errors: nil,
			Loc: &ast.SourceLocation{
				End: ast.Position{
					Column: 528,
					Line:   11,
				},
				File:   "interval_test.flux",
				Source: "package interval_test\n\n\nimport \"experimental\"\nimport \"interval\"\n\nexperimental.addDuration(d: 1d, to: 2020-01-01T00:00:00Z) == 2020-01-02T00:00:00Z or die()\nexperimental.addDuration(d: 1mo, to: 2020-01-01T00:00:00Z) == 2020-02-01T00:00:00Z or die()\nexperimental.addDuration(d: 1mo, to: 2020-01-31T00:00:00Z) == 2020-02-28T00:00:00Z or die()\nexperimental.addDuration(d: 1mo, to: 2020-02-28T00:00:00Z) == 2020-03-28T00:00:00Z or die()\ninterval.intervals(every: 1m, period: 1m, offset: 0s)(start: 2020-10-30T00:00:00Z, stop: 2020-10-30T00:10:00Z) == [{start: 2020-10-30T00:00:00Z, stop: 2020-10-30T00:00:00Z}, {start: 2020-10-30T00:00:00Z, stop: 2020-10-30T00:00:00Z}, {start: 2020-10-30T00:00:00Z, stop: 2020-10-30T00:00:00Z}, {start: 2020-10-30T00:00:00Z, stop: 2020-10-30T00:00:00Z}, {start: 2020-10-30T00:00:00Z, stop: 2020-10-30T00:00:00Z}, {start: 2020-10-30T00:00:00Z, stop: 2020-10-30T00:00:00Z}, {start: 2020-10-30T00:00:00Z, stop: 2020-10-30T00:00:00Z}]",
				Start: ast.Position{
					Column: 1,
					Line:   1,
				},
			},
		},
		Body: []ast.Statement{&ast.ExpressionStatement{
			BaseNode: ast.BaseNode{
				Errors: nil,
				Loc: &ast.SourceLocation{
					End: ast.Position{
						Column: 91,
						Line:   7,
					},
					File:   "interval_test.flux",
					Source: "experimental.addDuration(d: 1d, to: 2020-01-01T00:00:00Z) == 2020-01-02T00:00:00Z or die()",
					Start: ast.Position{
						Column: 1,
						Line:   7,
					},
				},
			},
			Expression: &ast.LogicalExpression{
				BaseNode: ast.BaseNode{
					Errors: nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 91,
							Line:   7,
						},
						File:   "interval_test.flux",
						Source: "experimental.addDuration(d: 1d, to: 2020-01-01T00:00:00Z) == 2020-01-02T00:00:00Z or die()",
						Start: ast.Position{
							Column: 1,
							Line:   7,
						},
					},
				},
				Left: &ast.BinaryExpression{
					BaseNode: ast.BaseNode{
						Errors: nil,
						Loc: &ast.SourceLocation{
							End: ast.Position{
								Column: 82,
								Line:   7,
							},
							File:   "interval_test.flux",
							Source: "experimental.addDuration(d: 1d, to: 2020-01-01T00:00:00Z) == 2020-01-02T00:00:00Z",
							Start: ast.Position{
								Column: 1,
								Line:   7,
							},
						},
					},
					Left: &ast.CallExpression{
						Arguments: []ast.Expression{&ast.ObjectExpression{
							BaseNode: ast.BaseNode{
								Errors: nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 57,
										Line:   7,
									},
									File:   "interval_test.flux",
									Source: "d: 1d, to: 2020-01-01T00:00:00Z",
									Start: ast.Position{
										Column: 26,
										Line:   7,
									},
								},
							},
							Properties: []*ast.Property{&ast.Property{
								BaseNode: ast.BaseNode{
									Errors: nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 31,
											Line:   7,
										},
										File:   "interval_test.flux",
										Source: "d: 1d",
										Start: ast.Position{
											Column: 26,
											Line:   7,
										},
									},
								},
								Key: &ast.Identifier{
									BaseNode: ast.BaseNode{
										Errors: nil,
										Loc: &ast.SourceLocation{
											End: ast.Position{
												Column: 27,
												Line:   7,
											},
											File:   "interval_test.flux",
											Source: "d",
											Start: ast.Position{
												Column: 26,
												Line:   7,
											},
										},
									},
									Name: "d",
								},
								Value: &ast.DurationLiteral{
									BaseNode: ast.BaseNode{
										Errors: nil,
										Loc: &ast.SourceLocation{
											End: ast.Position{
												Column: 31,
												Line:   7,
											},
											File:   "interval_test.flux",
											Source: "1d",
											Start: ast.Position{
												Column: 29,
												Line:   7,
											},
										},
									},
									Values: []ast.Duration{ast.Duration{
										Magnitude: int64(1),
										Unit:      "d",
									}},
								},
							}, &ast.Property{
								BaseNode: ast.BaseNode{
									Errors: nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 57,
											Line:   7,
										},
										File:   "interval_test.flux",
										Source: "to: 2020-01-01T00:00:00Z",
										Start: ast.Position{
											Column: 33,
											Line:   7,
										},
									},
								},
								Key: &ast.Identifier{
									BaseNode: ast.BaseNode{
										Errors: nil,
										Loc: &ast.SourceLocation{
											End: ast.Position{
												Column: 35,
												Line:   7,
											},
											File:   "interval_test.flux",
											Source: "to",
											Start: ast.Position{
												Column: 33,
												Line:   7,
											},
										},
									},
									Name: "to",
								},
								Value: &ast.DateTimeLiteral{
									BaseNode: ast.BaseNode{
										Errors: nil,
										Loc: &ast.SourceLocation{
											End: ast.Position{
												Column: 57,
												Line:   7,
											},
											File:   "interval_test.flux",
											Source: "2020-01-01T00:00:00Z",
											Start: ast.Position{
												Column: 37,
												Line:   7,
											},
										},
									},
									Value: parser.MustParseTime("2020-01-01T00:00:00Z"),
								},
							}},
							With: nil,
						}},
						BaseNode: ast.BaseNode{
							Errors: nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 58,
									Line:   7,
								},
								File:   "interval_test.flux",
								Source: "experimental.addDuration(d: 1d, to: 2020-01-01T00:00:00Z)",
								Start: ast.Position{
									Column: 1,
									Line:   7,
								},
							},
						},
						Callee: &ast.MemberExpression{
							BaseNode: ast.BaseNode{
								Errors: nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 25,
										Line:   7,
									},
									File:   "interval_test.flux",
									Source: "experimental.addDuration",
									Start: ast.Position{
										Column: 1,
										Line:   7,
									},
								},
							},
							Object: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Errors: nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 13,
											Line:   7,
										},
										File:   "interval_test.flux",
										Source: "experimental",
										Start: ast.Position{
											Column: 1,
											Line:   7,
										},
									},
								},
								Name: "experimental",
							},
							Property: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Errors: nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 25,
											Line:   7,
										},
										File:   "interval_test.flux",
										Source: "addDuration",
										Start: ast.Position{
											Column: 14,
											Line:   7,
										},
									},
								},
								Name: "addDuration",
							},
						},
					},
					Operator: 17,
					Right: &ast.DateTimeLiteral{
						BaseNode: ast.BaseNode{
							Errors: nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 82,
									Line:   7,
								},
								File:   "interval_test.flux",
								Source: "2020-01-02T00:00:00Z",
								Start: ast.Position{
									Column: 62,
									Line:   7,
								},
							},
						},
						Value: parser.MustParseTime("2020-01-02T00:00:00Z"),
					},
				},
				Operator: 2,
				Right: &ast.CallExpression{
					Arguments: nil,
					BaseNode: ast.BaseNode{
						Errors: nil,
						Loc: &ast.SourceLocation{
							End: ast.Position{
								Column: 91,
								Line:   7,
							},
							File:   "interval_test.flux",
							Source: "die()",
							Start: ast.Position{
								Column: 86,
								Line:   7,
							},
						},
					},
					Callee: &ast.Identifier{
						BaseNode: ast.BaseNode{
							Errors: nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 89,
									Line:   7,
								},
								File:   "interval_test.flux",
								Source: "die",
								Start: ast.Position{
									Column: 86,
									Line:   7,
								},
							},
						},
						Name: "die",
					},
				},
			},
		}, &ast.ExpressionStatement{
			BaseNode: ast.BaseNode{
				Errors: nil,
				Loc: &ast.SourceLocation{
					End: ast.Position{
						Column: 92,
						Line:   8,
					},
					File:   "interval_test.flux",
					Source: "experimental.addDuration(d: 1mo, to: 2020-01-01T00:00:00Z) == 2020-02-01T00:00:00Z or die()",
					Start: ast.Position{
						Column: 1,
						Line:   8,
					},
				},
			},
			Expression: &ast.LogicalExpression{
				BaseNode: ast.BaseNode{
					Errors: nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 92,
							Line:   8,
						},
						File:   "interval_test.flux",
						Source: "experimental.addDuration(d: 1mo, to: 2020-01-01T00:00:00Z) == 2020-02-01T00:00:00Z or die()",
						Start: ast.Position{
							Column: 1,
							Line:   8,
						},
					},
				},
				Left: &ast.BinaryExpression{
					BaseNode: ast.BaseNode{
						Errors: nil,
						Loc: &ast.SourceLocation{
							End: ast.Position{
								Column: 83,
								Line:   8,
							},
							File:   "interval_test.flux",
							Source: "experimental.addDuration(d: 1mo, to: 2020-01-01T00:00:00Z) == 2020-02-01T00:00:00Z",
							Start: ast.Position{
								Column: 1,
								Line:   8,
							},
						},
					},
					Left: &ast.CallExpression{
						Arguments: []ast.Expression{&ast.ObjectExpression{
							BaseNode: ast.BaseNode{
								Errors: nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 58,
										Line:   8,
									},
									File:   "interval_test.flux",
									Source: "d: 1mo, to: 2020-01-01T00:00:00Z",
									Start: ast.Position{
										Column: 26,
										Line:   8,
									},
								},
							},
							Properties: []*ast.Property{&ast.Property{
								BaseNode: ast.BaseNode{
									Errors: nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 32,
											Line:   8,
										},
										File:   "interval_test.flux",
										Source: "d: 1mo",
										Start: ast.Position{
											Column: 26,
											Line:   8,
										},
									},
								},
								Key: &ast.Identifier{
									BaseNode: ast.BaseNode{
										Errors: nil,
										Loc: &ast.SourceLocation{
											End: ast.Position{
												Column: 27,
												Line:   8,
											},
											File:   "interval_test.flux",
											Source: "d",
											Start: ast.Position{
												Column: 26,
												Line:   8,
											},
										},
									},
									Name: "d",
								},
								Value: &ast.DurationLiteral{
									BaseNode: ast.BaseNode{
										Errors: nil,
										Loc: &ast.SourceLocation{
											End: ast.Position{
												Column: 32,
												Line:   8,
											},
											File:   "interval_test.flux",
											Source: "1mo",
											Start: ast.Position{
												Column: 29,
												Line:   8,
											},
										},
									},
									Values: []ast.Duration{ast.Duration{
										Magnitude: int64(1),
										Unit:      "mo",
									}},
								},
							}, &ast.Property{
								BaseNode: ast.BaseNode{
									Errors: nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 58,
											Line:   8,
										},
										File:   "interval_test.flux",
										Source: "to: 2020-01-01T00:00:00Z",
										Start: ast.Position{
											Column: 34,
											Line:   8,
										},
									},
								},
								Key: &ast.Identifier{
									BaseNode: ast.BaseNode{
										Errors: nil,
										Loc: &ast.SourceLocation{
											End: ast.Position{
												Column: 36,
												Line:   8,
											},
											File:   "interval_test.flux",
											Source: "to",
											Start: ast.Position{
												Column: 34,
												Line:   8,
											},
										},
									},
									Name: "to",
								},
								Value: &ast.DateTimeLiteral{
									BaseNode: ast.BaseNode{
										Errors: nil,
										Loc: &ast.SourceLocation{
											End: ast.Position{
												Column: 58,
												Line:   8,
											},
											File:   "interval_test.flux",
											Source: "2020-01-01T00:00:00Z",
											Start: ast.Position{
												Column: 38,
												Line:   8,
											},
										},
									},
									Value: parser.MustParseTime("2020-01-01T00:00:00Z"),
								},
							}},
							With: nil,
						}},
						BaseNode: ast.BaseNode{
							Errors: nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 59,
									Line:   8,
								},
								File:   "interval_test.flux",
								Source: "experimental.addDuration(d: 1mo, to: 2020-01-01T00:00:00Z)",
								Start: ast.Position{
									Column: 1,
									Line:   8,
								},
							},
						},
						Callee: &ast.MemberExpression{
							BaseNode: ast.BaseNode{
								Errors: nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 25,
										Line:   8,
									},
									File:   "interval_test.flux",
									Source: "experimental.addDuration",
									Start: ast.Position{
										Column: 1,
										Line:   8,
									},
								},
							},
							Object: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Errors: nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 13,
											Line:   8,
										},
										File:   "interval_test.flux",
										Source: "experimental",
										Start: ast.Position{
											Column: 1,
											Line:   8,
										},
									},
								},
								Name: "experimental",
							},
							Property: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Errors: nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 25,
											Line:   8,
										},
										File:   "interval_test.flux",
										Source: "addDuration",
										Start: ast.Position{
											Column: 14,
											Line:   8,
										},
									},
								},
								Name: "addDuration",
							},
						},
					},
					Operator: 17,
					Right: &ast.DateTimeLiteral{
						BaseNode: ast.BaseNode{
							Errors: nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 83,
									Line:   8,
								},
								File:   "interval_test.flux",
								Source: "2020-02-01T00:00:00Z",
								Start: ast.Position{
									Column: 63,
									Line:   8,
								},
							},
						},
						Value: parser.MustParseTime("2020-02-01T00:00:00Z"),
					},
				},
				Operator: 2,
				Right: &ast.CallExpression{
					Arguments: nil,
					BaseNode: ast.BaseNode{
						Errors: nil,
						Loc: &ast.SourceLocation{
							End: ast.Position{
								Column: 92,
								Line:   8,
							},
							File:   "interval_test.flux",
							Source: "die()",
							Start: ast.Position{
								Column: 87,
								Line:   8,
							},
						},
					},
					Callee: &ast.Identifier{
						BaseNode: ast.BaseNode{
							Errors: nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 90,
									Line:   8,
								},
								File:   "interval_test.flux",
								Source: "die",
								Start: ast.Position{
									Column: 87,
									Line:   8,
								},
							},
						},
						Name: "die",
					},
				},
			},
		}, &ast.ExpressionStatement{
			BaseNode: ast.BaseNode{
				Errors: nil,
				Loc: &ast.SourceLocation{
					End: ast.Position{
						Column: 92,
						Line:   9,
					},
					File:   "interval_test.flux",
					Source: "experimental.addDuration(d: 1mo, to: 2020-01-31T00:00:00Z) == 2020-02-28T00:00:00Z or die()",
					Start: ast.Position{
						Column: 1,
						Line:   9,
					},
				},
			},
			Expression: &ast.LogicalExpression{
				BaseNode: ast.BaseNode{
					Errors: nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 92,
							Line:   9,
						},
						File:   "interval_test.flux",
						Source: "experimental.addDuration(d: 1mo, to: 2020-01-31T00:00:00Z) == 2020-02-28T00:00:00Z or die()",
						Start: ast.Position{
							Column: 1,
							Line:   9,
						},
					},
				},
				Left: &ast.BinaryExpression{
					BaseNode: ast.BaseNode{
						Errors: nil,
						Loc: &ast.SourceLocation{
							End: ast.Position{
								Column: 83,
								Line:   9,
							},
							File:   "interval_test.flux",
							Source: "experimental.addDuration(d: 1mo, to: 2020-01-31T00:00:00Z) == 2020-02-28T00:00:00Z",
							Start: ast.Position{
								Column: 1,
								Line:   9,
							},
						},
					},
					Left: &ast.CallExpression{
						Arguments: []ast.Expression{&ast.ObjectExpression{
							BaseNode: ast.BaseNode{
								Errors: nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 58,
										Line:   9,
									},
									File:   "interval_test.flux",
									Source: "d: 1mo, to: 2020-01-31T00:00:00Z",
									Start: ast.Position{
										Column: 26,
										Line:   9,
									},
								},
							},
							Properties: []*ast.Property{&ast.Property{
								BaseNode: ast.BaseNode{
									Errors: nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 32,
											Line:   9,
										},
										File:   "interval_test.flux",
										Source: "d: 1mo",
										Start: ast.Position{
											Column: 26,
											Line:   9,
										},
									},
								},
								Key: &ast.Identifier{
									BaseNode: ast.BaseNode{
										Errors: nil,
										Loc: &ast.SourceLocation{
											End: ast.Position{
												Column: 27,
												Line:   9,
											},
											File:   "interval_test.flux",
											Source: "d",
											Start: ast.Position{
												Column: 26,
												Line:   9,
											},
										},
									},
									Name: "d",
								},
								Value: &ast.DurationLiteral{
									BaseNode: ast.BaseNode{
										Errors: nil,
										Loc: &ast.SourceLocation{
											End: ast.Position{
												Column: 32,
												Line:   9,
											},
											File:   "interval_test.flux",
											Source: "1mo",
											Start: ast.Position{
												Column: 29,
												Line:   9,
											},
										},
									},
									Values: []ast.Duration{ast.Duration{
										Magnitude: int64(1),
										Unit:      "mo",
									}},
								},
							}, &ast.Property{
								BaseNode: ast.BaseNode{
									Errors: nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 58,
											Line:   9,
										},
										File:   "interval_test.flux",
										Source: "to: 2020-01-31T00:00:00Z",
										Start: ast.Position{
											Column: 34,
											Line:   9,
										},
									},
								},
								Key: &ast.Identifier{
									BaseNode: ast.BaseNode{
										Errors: nil,
										Loc: &ast.SourceLocation{
											End: ast.Position{
												Column: 36,
												Line:   9,
											},
											File:   "interval_test.flux",
											Source: "to",
											Start: ast.Position{
												Column: 34,
												Line:   9,
											},
										},
									},
									Name: "to",
								},
								Value: &ast.DateTimeLiteral{
									BaseNode: ast.BaseNode{
										Errors: nil,
										Loc: &ast.SourceLocation{
											End: ast.Position{
												Column: 58,
												Line:   9,
											},
											File:   "interval_test.flux",
											Source: "2020-01-31T00:00:00Z",
											Start: ast.Position{
												Column: 38,
												Line:   9,
											},
										},
									},
									Value: parser.MustParseTime("2020-01-31T00:00:00Z"),
								},
							}},
							With: nil,
						}},
						BaseNode: ast.BaseNode{
							Errors: nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 59,
									Line:   9,
								},
								File:   "interval_test.flux",
								Source: "experimental.addDuration(d: 1mo, to: 2020-01-31T00:00:00Z)",
								Start: ast.Position{
									Column: 1,
									Line:   9,
								},
							},
						},
						Callee: &ast.MemberExpression{
							BaseNode: ast.BaseNode{
								Errors: nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 25,
										Line:   9,
									},
									File:   "interval_test.flux",
									Source: "experimental.addDuration",
									Start: ast.Position{
										Column: 1,
										Line:   9,
									},
								},
							},
							Object: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Errors: nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 13,
											Line:   9,
										},
										File:   "interval_test.flux",
										Source: "experimental",
										Start: ast.Position{
											Column: 1,
											Line:   9,
										},
									},
								},
								Name: "experimental",
							},
							Property: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Errors: nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 25,
											Line:   9,
										},
										File:   "interval_test.flux",
										Source: "addDuration",
										Start: ast.Position{
											Column: 14,
											Line:   9,
										},
									},
								},
								Name: "addDuration",
							},
						},
					},
					Operator: 17,
					Right: &ast.DateTimeLiteral{
						BaseNode: ast.BaseNode{
							Errors: nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 83,
									Line:   9,
								},
								File:   "interval_test.flux",
								Source: "2020-02-28T00:00:00Z",
								Start: ast.Position{
									Column: 63,
									Line:   9,
								},
							},
						},
						Value: parser.MustParseTime("2020-02-28T00:00:00Z"),
					},
				},
				Operator: 2,
				Right: &ast.CallExpression{
					Arguments: nil,
					BaseNode: ast.BaseNode{
						Errors: nil,
						Loc: &ast.SourceLocation{
							End: ast.Position{
								Column: 92,
								Line:   9,
							},
							File:   "interval_test.flux",
							Source: "die()",
							Start: ast.Position{
								Column: 87,
								Line:   9,
							},
						},
					},
					Callee: &ast.Identifier{
						BaseNode: ast.BaseNode{
							Errors: nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 90,
									Line:   9,
								},
								File:   "interval_test.flux",
								Source: "die",
								Start: ast.Position{
									Column: 87,
									Line:   9,
								},
							},
						},
						Name: "die",
					},
				},
			},
		}, &ast.ExpressionStatement{
			BaseNode: ast.BaseNode{
				Errors: nil,
				Loc: &ast.SourceLocation{
					End: ast.Position{
						Column: 92,
						Line:   10,
					},
					File:   "interval_test.flux",
					Source: "experimental.addDuration(d: 1mo, to: 2020-02-28T00:00:00Z) == 2020-03-28T00:00:00Z or die()",
					Start: ast.Position{
						Column: 1,
						Line:   10,
					},
				},
			},
			Expression: &ast.LogicalExpression{
				BaseNode: ast.BaseNode{
					Errors: nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 92,
							Line:   10,
						},
						File:   "interval_test.flux",
						Source: "experimental.addDuration(d: 1mo, to: 2020-02-28T00:00:00Z) == 2020-03-28T00:00:00Z or die()",
						Start: ast.Position{
							Column: 1,
							Line:   10,
						},
					},
				},
				Left: &ast.BinaryExpression{
					BaseNode: ast.BaseNode{
						Errors: nil,
						Loc: &ast.SourceLocation{
							End: ast.Position{
								Column: 83,
								Line:   10,
							},
							File:   "interval_test.flux",
							Source: "experimental.addDuration(d: 1mo, to: 2020-02-28T00:00:00Z) == 2020-03-28T00:00:00Z",
							Start: ast.Position{
								Column: 1,
								Line:   10,
							},
						},
					},
					Left: &ast.CallExpression{
						Arguments: []ast.Expression{&ast.ObjectExpression{
							BaseNode: ast.BaseNode{
								Errors: nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 58,
										Line:   10,
									},
									File:   "interval_test.flux",
									Source: "d: 1mo, to: 2020-02-28T00:00:00Z",
									Start: ast.Position{
										Column: 26,
										Line:   10,
									},
								},
							},
							Properties: []*ast.Property{&ast.Property{
								BaseNode: ast.BaseNode{
									Errors: nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 32,
											Line:   10,
										},
										File:   "interval_test.flux",
										Source: "d: 1mo",
										Start: ast.Position{
											Column: 26,
											Line:   10,
										},
									},
								},
								Key: &ast.Identifier{
									BaseNode: ast.BaseNode{
										Errors: nil,
										Loc: &ast.SourceLocation{
											End: ast.Position{
												Column: 27,
												Line:   10,
											},
											File:   "interval_test.flux",
											Source: "d",
											Start: ast.Position{
												Column: 26,
												Line:   10,
											},
										},
									},
									Name: "d",
								},
								Value: &ast.DurationLiteral{
									BaseNode: ast.BaseNode{
										Errors: nil,
										Loc: &ast.SourceLocation{
											End: ast.Position{
												Column: 32,
												Line:   10,
											},
											File:   "interval_test.flux",
											Source: "1mo",
											Start: ast.Position{
												Column: 29,
												Line:   10,
											},
										},
									},
									Values: []ast.Duration{ast.Duration{
										Magnitude: int64(1),
										Unit:      "mo",
									}},
								},
							}, &ast.Property{
								BaseNode: ast.BaseNode{
									Errors: nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 58,
											Line:   10,
										},
										File:   "interval_test.flux",
										Source: "to: 2020-02-28T00:00:00Z",
										Start: ast.Position{
											Column: 34,
											Line:   10,
										},
									},
								},
								Key: &ast.Identifier{
									BaseNode: ast.BaseNode{
										Errors: nil,
										Loc: &ast.SourceLocation{
											End: ast.Position{
												Column: 36,
												Line:   10,
											},
											File:   "interval_test.flux",
											Source: "to",
											Start: ast.Position{
												Column: 34,
												Line:   10,
											},
										},
									},
									Name: "to",
								},
								Value: &ast.DateTimeLiteral{
									BaseNode: ast.BaseNode{
										Errors: nil,
										Loc: &ast.SourceLocation{
											End: ast.Position{
												Column: 58,
												Line:   10,
											},
											File:   "interval_test.flux",
											Source: "2020-02-28T00:00:00Z",
											Start: ast.Position{
												Column: 38,
												Line:   10,
											},
										},
									},
									Value: parser.MustParseTime("2020-02-28T00:00:00Z"),
								},
							}},
							With: nil,
						}},
						BaseNode: ast.BaseNode{
							Errors: nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 59,
									Line:   10,
								},
								File:   "interval_test.flux",
								Source: "experimental.addDuration(d: 1mo, to: 2020-02-28T00:00:00Z)",
								Start: ast.Position{
									Column: 1,
									Line:   10,
								},
							},
						},
						Callee: &ast.MemberExpression{
							BaseNode: ast.BaseNode{
								Errors: nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 25,
										Line:   10,
									},
									File:   "interval_test.flux",
									Source: "experimental.addDuration",
									Start: ast.Position{
										Column: 1,
										Line:   10,
									},
								},
							},
							Object: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Errors: nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 13,
											Line:   10,
										},
										File:   "interval_test.flux",
										Source: "experimental",
										Start: ast.Position{
											Column: 1,
											Line:   10,
										},
									},
								},
								Name: "experimental",
							},
							Property: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Errors: nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 25,
											Line:   10,
										},
										File:   "interval_test.flux",
										Source: "addDuration",
										Start: ast.Position{
											Column: 14,
											Line:   10,
										},
									},
								},
								Name: "addDuration",
							},
						},
					},
					Operator: 17,
					Right: &ast.DateTimeLiteral{
						BaseNode: ast.BaseNode{
							Errors: nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 83,
									Line:   10,
								},
								File:   "interval_test.flux",
								Source: "2020-03-28T00:00:00Z",
								Start: ast.Position{
									Column: 63,
									Line:   10,
								},
							},
						},
						Value: parser.MustParseTime("2020-03-28T00:00:00Z"),
					},
				},
				Operator: 2,
				Right: &ast.CallExpression{
					Arguments: nil,
					BaseNode: ast.BaseNode{
						Errors: nil,
						Loc: &ast.SourceLocation{
							End: ast.Position{
								Column: 92,
								Line:   10,
							},
							File:   "interval_test.flux",
							Source: "die()",
							Start: ast.Position{
								Column: 87,
								Line:   10,
							},
						},
					},
					Callee: &ast.Identifier{
						BaseNode: ast.BaseNode{
							Errors: nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 90,
									Line:   10,
								},
								File:   "interval_test.flux",
								Source: "die",
								Start: ast.Position{
									Column: 87,
									Line:   10,
								},
							},
						},
						Name: "die",
					},
				},
			},
		}, &ast.ExpressionStatement{
			BaseNode: ast.BaseNode{
				Errors: nil,
				Loc: &ast.SourceLocation{
					End: ast.Position{
						Column: 528,
						Line:   11,
					},
					File:   "interval_test.flux",
					Source: "interval.intervals(every: 1m, period: 1m, offset: 0s)(start: 2020-10-30T00:00:00Z, stop: 2020-10-30T00:10:00Z) == [{start: 2020-10-30T00:00:00Z, stop: 2020-10-30T00:00:00Z}, {start: 2020-10-30T00:00:00Z, stop: 2020-10-30T00:00:00Z}, {start: 2020-10-30T00:00:00Z, stop: 2020-10-30T00:00:00Z}, {start: 2020-10-30T00:00:00Z, stop: 2020-10-30T00:00:00Z}, {start: 2020-10-30T00:00:00Z, stop: 2020-10-30T00:00:00Z}, {start: 2020-10-30T00:00:00Z, stop: 2020-10-30T00:00:00Z}, {start: 2020-10-30T00:00:00Z, stop: 2020-10-30T00:00:00Z}]",
					Start: ast.Position{
						Column: 1,
						Line:   11,
					},
				},
			},
			Expression: &ast.BinaryExpression{
				BaseNode: ast.BaseNode{
					Errors: nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 528,
							Line:   11,
						},
						File:   "interval_test.flux",
						Source: "interval.intervals(every: 1m, period: 1m, offset: 0s)(start: 2020-10-30T00:00:00Z, stop: 2020-10-30T00:10:00Z) == [{start: 2020-10-30T00:00:00Z, stop: 2020-10-30T00:00:00Z}, {start: 2020-10-30T00:00:00Z, stop: 2020-10-30T00:00:00Z}, {start: 2020-10-30T00:00:00Z, stop: 2020-10-30T00:00:00Z}, {start: 2020-10-30T00:00:00Z, stop: 2020-10-30T00:00:00Z}, {start: 2020-10-30T00:00:00Z, stop: 2020-10-30T00:00:00Z}, {start: 2020-10-30T00:00:00Z, stop: 2020-10-30T00:00:00Z}, {start: 2020-10-30T00:00:00Z, stop: 2020-10-30T00:00:00Z}]",
						Start: ast.Position{
							Column: 1,
							Line:   11,
						},
					},
				},
				Left: &ast.CallExpression{
					Arguments: []ast.Expression{&ast.ObjectExpression{
						BaseNode: ast.BaseNode{
							Errors: nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 110,
									Line:   11,
								},
								File:   "interval_test.flux",
								Source: "start: 2020-10-30T00:00:00Z, stop: 2020-10-30T00:10:00Z",
								Start: ast.Position{
									Column: 55,
									Line:   11,
								},
							},
						},
						Properties: []*ast.Property{&ast.Property{
							BaseNode: ast.BaseNode{
								Errors: nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 82,
										Line:   11,
									},
									File:   "interval_test.flux",
									Source: "start: 2020-10-30T00:00:00Z",
									Start: ast.Position{
										Column: 55,
										Line:   11,
									},
								},
							},
							Key: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Errors: nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 60,
											Line:   11,
										},
										File:   "interval_test.flux",
										Source: "start",
										Start: ast.Position{
											Column: 55,
											Line:   11,
										},
									},
								},
								Name: "start",
							},
							Value: &ast.DateTimeLiteral{
								BaseNode: ast.BaseNode{
									Errors: nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 82,
											Line:   11,
										},
										File:   "interval_test.flux",
										Source: "2020-10-30T00:00:00Z",
										Start: ast.Position{
											Column: 62,
											Line:   11,
										},
									},
								},
								Value: parser.MustParseTime("2020-10-30T00:00:00Z"),
							},
						}, &ast.Property{
							BaseNode: ast.BaseNode{
								Errors: nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 110,
										Line:   11,
									},
									File:   "interval_test.flux",
									Source: "stop: 2020-10-30T00:10:00Z",
									Start: ast.Position{
										Column: 84,
										Line:   11,
									},
								},
							},
							Key: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Errors: nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 88,
											Line:   11,
										},
										File:   "interval_test.flux",
										Source: "stop",
										Start: ast.Position{
											Column: 84,
											Line:   11,
										},
									},
								},
								Name: "stop",
							},
							Value: &ast.DateTimeLiteral{
								BaseNode: ast.BaseNode{
									Errors: nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 110,
											Line:   11,
										},
										File:   "interval_test.flux",
										Source: "2020-10-30T00:10:00Z",
										Start: ast.Position{
											Column: 90,
											Line:   11,
										},
									},
								},
								Value: parser.MustParseTime("2020-10-30T00:10:00Z"),
							},
						}},
						With: nil,
					}},
					BaseNode: ast.BaseNode{
						Errors: nil,
						Loc: &ast.SourceLocation{
							End: ast.Position{
								Column: 111,
								Line:   11,
							},
							File:   "interval_test.flux",
							Source: "interval.intervals(every: 1m, period: 1m, offset: 0s)(start: 2020-10-30T00:00:00Z, stop: 2020-10-30T00:10:00Z)",
							Start: ast.Position{
								Column: 1,
								Line:   11,
							},
						},
					},
					Callee: &ast.CallExpression{
						Arguments: []ast.Expression{&ast.ObjectExpression{
							BaseNode: ast.BaseNode{
								Errors: nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 53,
										Line:   11,
									},
									File:   "interval_test.flux",
									Source: "every: 1m, period: 1m, offset: 0s",
									Start: ast.Position{
										Column: 20,
										Line:   11,
									},
								},
							},
							Properties: []*ast.Property{&ast.Property{
								BaseNode: ast.BaseNode{
									Errors: nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 29,
											Line:   11,
										},
										File:   "interval_test.flux",
										Source: "every: 1m",
										Start: ast.Position{
											Column: 20,
											Line:   11,
										},
									},
								},
								Key: &ast.Identifier{
									BaseNode: ast.BaseNode{
										Errors: nil,
										Loc: &ast.SourceLocation{
											End: ast.Position{
												Column: 25,
												Line:   11,
											},
											File:   "interval_test.flux",
											Source: "every",
											Start: ast.Position{
												Column: 20,
												Line:   11,
											},
										},
									},
									Name: "every",
								},
								Value: &ast.DurationLiteral{
									BaseNode: ast.BaseNode{
										Errors: nil,
										Loc: &ast.SourceLocation{
											End: ast.Position{
												Column: 29,
												Line:   11,
											},
											File:   "interval_test.flux",
											Source: "1m",
											Start: ast.Position{
												Column: 27,
												Line:   11,
											},
										},
									},
									Values: []ast.Duration{ast.Duration{
										Magnitude: int64(1),
										Unit:      "m",
									}},
								},
							}, &ast.Property{
								BaseNode: ast.BaseNode{
									Errors: nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 41,
											Line:   11,
										},
										File:   "interval_test.flux",
										Source: "period: 1m",
										Start: ast.Position{
											Column: 31,
											Line:   11,
										},
									},
								},
								Key: &ast.Identifier{
									BaseNode: ast.BaseNode{
										Errors: nil,
										Loc: &ast.SourceLocation{
											End: ast.Position{
												Column: 37,
												Line:   11,
											},
											File:   "interval_test.flux",
											Source: "period",
											Start: ast.Position{
												Column: 31,
												Line:   11,
											},
										},
									},
									Name: "period",
								},
								Value: &ast.DurationLiteral{
									BaseNode: ast.BaseNode{
										Errors: nil,
										Loc: &ast.SourceLocation{
											End: ast.Position{
												Column: 41,
												Line:   11,
											},
											File:   "interval_test.flux",
											Source: "1m",
											Start: ast.Position{
												Column: 39,
												Line:   11,
											},
										},
									},
									Values: []ast.Duration{ast.Duration{
										Magnitude: int64(1),
										Unit:      "m",
									}},
								},
							}, &ast.Property{
								BaseNode: ast.BaseNode{
									Errors: nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 53,
											Line:   11,
										},
										File:   "interval_test.flux",
										Source: "offset: 0s",
										Start: ast.Position{
											Column: 43,
											Line:   11,
										},
									},
								},
								Key: &ast.Identifier{
									BaseNode: ast.BaseNode{
										Errors: nil,
										Loc: &ast.SourceLocation{
											End: ast.Position{
												Column: 49,
												Line:   11,
											},
											File:   "interval_test.flux",
											Source: "offset",
											Start: ast.Position{
												Column: 43,
												Line:   11,
											},
										},
									},
									Name: "offset",
								},
								Value: &ast.DurationLiteral{
									BaseNode: ast.BaseNode{
										Errors: nil,
										Loc: &ast.SourceLocation{
											End: ast.Position{
												Column: 53,
												Line:   11,
											},
											File:   "interval_test.flux",
											Source: "0s",
											Start: ast.Position{
												Column: 51,
												Line:   11,
											},
										},
									},
									Values: []ast.Duration{ast.Duration{
										Magnitude: int64(0),
										Unit:      "s",
									}},
								},
							}},
							With: nil,
						}},
						BaseNode: ast.BaseNode{
							Errors: nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 54,
									Line:   11,
								},
								File:   "interval_test.flux",
								Source: "interval.intervals(every: 1m, period: 1m, offset: 0s)",
								Start: ast.Position{
									Column: 1,
									Line:   11,
								},
							},
						},
						Callee: &ast.MemberExpression{
							BaseNode: ast.BaseNode{
								Errors: nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 19,
										Line:   11,
									},
									File:   "interval_test.flux",
									Source: "interval.intervals",
									Start: ast.Position{
										Column: 1,
										Line:   11,
									},
								},
							},
							Object: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Errors: nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 9,
											Line:   11,
										},
										File:   "interval_test.flux",
										Source: "interval",
										Start: ast.Position{
											Column: 1,
											Line:   11,
										},
									},
								},
								Name: "interval",
							},
							Property: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Errors: nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 19,
											Line:   11,
										},
										File:   "interval_test.flux",
										Source: "intervals",
										Start: ast.Position{
											Column: 10,
											Line:   11,
										},
									},
								},
								Name: "intervals",
							},
						},
					},
				},
				Operator: 17,
				Right: &ast.ArrayExpression{
					BaseNode: ast.BaseNode{
						Errors: nil,
						Loc: &ast.SourceLocation{
							End: ast.Position{
								Column: 528,
								Line:   11,
							},
							File:   "interval_test.flux",
							Source: "[{start: 2020-10-30T00:00:00Z, stop: 2020-10-30T00:00:00Z}, {start: 2020-10-30T00:00:00Z, stop: 2020-10-30T00:00:00Z}, {start: 2020-10-30T00:00:00Z, stop: 2020-10-30T00:00:00Z}, {start: 2020-10-30T00:00:00Z, stop: 2020-10-30T00:00:00Z}, {start: 2020-10-30T00:00:00Z, stop: 2020-10-30T00:00:00Z}, {start: 2020-10-30T00:00:00Z, stop: 2020-10-30T00:00:00Z}, {start: 2020-10-30T00:00:00Z, stop: 2020-10-30T00:00:00Z}]",
							Start: ast.Position{
								Column: 115,
								Line:   11,
							},
						},
					},
					Elements: []ast.Expression{&ast.ObjectExpression{
						BaseNode: ast.BaseNode{
							Errors: nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 173,
									Line:   11,
								},
								File:   "interval_test.flux",
								Source: "{start: 2020-10-30T00:00:00Z, stop: 2020-10-30T00:00:00Z}",
								Start: ast.Position{
									Column: 116,
									Line:   11,
								},
							},
						},
						Properties: []*ast.Property{&ast.Property{
							BaseNode: ast.BaseNode{
								Errors: nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 144,
										Line:   11,
									},
									File:   "interval_test.flux",
									Source: "start: 2020-10-30T00:00:00Z",
									Start: ast.Position{
										Column: 117,
										Line:   11,
									},
								},
							},
							Key: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Errors: nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 122,
											Line:   11,
										},
										File:   "interval_test.flux",
										Source: "start",
										Start: ast.Position{
											Column: 117,
											Line:   11,
										},
									},
								},
								Name: "start",
							},
							Value: &ast.DateTimeLiteral{
								BaseNode: ast.BaseNode{
									Errors: nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 144,
											Line:   11,
										},
										File:   "interval_test.flux",
										Source: "2020-10-30T00:00:00Z",
										Start: ast.Position{
											Column: 124,
											Line:   11,
										},
									},
								},
								Value: parser.MustParseTime("2020-10-30T00:00:00Z"),
							},
						}, &ast.Property{
							BaseNode: ast.BaseNode{
								Errors: nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 172,
										Line:   11,
									},
									File:   "interval_test.flux",
									Source: "stop: 2020-10-30T00:00:00Z",
									Start: ast.Position{
										Column: 146,
										Line:   11,
									},
								},
							},
							Key: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Errors: nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 150,
											Line:   11,
										},
										File:   "interval_test.flux",
										Source: "stop",
										Start: ast.Position{
											Column: 146,
											Line:   11,
										},
									},
								},
								Name: "stop",
							},
							Value: &ast.DateTimeLiteral{
								BaseNode: ast.BaseNode{
									Errors: nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 172,
											Line:   11,
										},
										File:   "interval_test.flux",
										Source: "2020-10-30T00:00:00Z",
										Start: ast.Position{
											Column: 152,
											Line:   11,
										},
									},
								},
								Value: parser.MustParseTime("2020-10-30T00:00:00Z"),
							},
						}},
						With: nil,
					}, &ast.ObjectExpression{
						BaseNode: ast.BaseNode{
							Errors: nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 232,
									Line:   11,
								},
								File:   "interval_test.flux",
								Source: "{start: 2020-10-30T00:00:00Z, stop: 2020-10-30T00:00:00Z}",
								Start: ast.Position{
									Column: 175,
									Line:   11,
								},
							},
						},
						Properties: []*ast.Property{&ast.Property{
							BaseNode: ast.BaseNode{
								Errors: nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 203,
										Line:   11,
									},
									File:   "interval_test.flux",
									Source: "start: 2020-10-30T00:00:00Z",
									Start: ast.Position{
										Column: 176,
										Line:   11,
									},
								},
							},
							Key: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Errors: nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 181,
											Line:   11,
										},
										File:   "interval_test.flux",
										Source: "start",
										Start: ast.Position{
											Column: 176,
											Line:   11,
										},
									},
								},
								Name: "start",
							},
							Value: &ast.DateTimeLiteral{
								BaseNode: ast.BaseNode{
									Errors: nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 203,
											Line:   11,
										},
										File:   "interval_test.flux",
										Source: "2020-10-30T00:00:00Z",
										Start: ast.Position{
											Column: 183,
											Line:   11,
										},
									},
								},
								Value: parser.MustParseTime("2020-10-30T00:00:00Z"),
							},
						}, &ast.Property{
							BaseNode: ast.BaseNode{
								Errors: nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 231,
										Line:   11,
									},
									File:   "interval_test.flux",
									Source: "stop: 2020-10-30T00:00:00Z",
									Start: ast.Position{
										Column: 205,
										Line:   11,
									},
								},
							},
							Key: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Errors: nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 209,
											Line:   11,
										},
										File:   "interval_test.flux",
										Source: "stop",
										Start: ast.Position{
											Column: 205,
											Line:   11,
										},
									},
								},
								Name: "stop",
							},
							Value: &ast.DateTimeLiteral{
								BaseNode: ast.BaseNode{
									Errors: nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 231,
											Line:   11,
										},
										File:   "interval_test.flux",
										Source: "2020-10-30T00:00:00Z",
										Start: ast.Position{
											Column: 211,
											Line:   11,
										},
									},
								},
								Value: parser.MustParseTime("2020-10-30T00:00:00Z"),
							},
						}},
						With: nil,
					}, &ast.ObjectExpression{
						BaseNode: ast.BaseNode{
							Errors: nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 291,
									Line:   11,
								},
								File:   "interval_test.flux",
								Source: "{start: 2020-10-30T00:00:00Z, stop: 2020-10-30T00:00:00Z}",
								Start: ast.Position{
									Column: 234,
									Line:   11,
								},
							},
						},
						Properties: []*ast.Property{&ast.Property{
							BaseNode: ast.BaseNode{
								Errors: nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 262,
										Line:   11,
									},
									File:   "interval_test.flux",
									Source: "start: 2020-10-30T00:00:00Z",
									Start: ast.Position{
										Column: 235,
										Line:   11,
									},
								},
							},
							Key: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Errors: nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 240,
											Line:   11,
										},
										File:   "interval_test.flux",
										Source: "start",
										Start: ast.Position{
											Column: 235,
											Line:   11,
										},
									},
								},
								Name: "start",
							},
							Value: &ast.DateTimeLiteral{
								BaseNode: ast.BaseNode{
									Errors: nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 262,
											Line:   11,
										},
										File:   "interval_test.flux",
										Source: "2020-10-30T00:00:00Z",
										Start: ast.Position{
											Column: 242,
											Line:   11,
										},
									},
								},
								Value: parser.MustParseTime("2020-10-30T00:00:00Z"),
							},
						}, &ast.Property{
							BaseNode: ast.BaseNode{
								Errors: nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 290,
										Line:   11,
									},
									File:   "interval_test.flux",
									Source: "stop: 2020-10-30T00:00:00Z",
									Start: ast.Position{
										Column: 264,
										Line:   11,
									},
								},
							},
							Key: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Errors: nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 268,
											Line:   11,
										},
										File:   "interval_test.flux",
										Source: "stop",
										Start: ast.Position{
											Column: 264,
											Line:   11,
										},
									},
								},
								Name: "stop",
							},
							Value: &ast.DateTimeLiteral{
								BaseNode: ast.BaseNode{
									Errors: nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 290,
											Line:   11,
										},
										File:   "interval_test.flux",
										Source: "2020-10-30T00:00:00Z",
										Start: ast.Position{
											Column: 270,
											Line:   11,
										},
									},
								},
								Value: parser.MustParseTime("2020-10-30T00:00:00Z"),
							},
						}},
						With: nil,
					}, &ast.ObjectExpression{
						BaseNode: ast.BaseNode{
							Errors: nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 350,
									Line:   11,
								},
								File:   "interval_test.flux",
								Source: "{start: 2020-10-30T00:00:00Z, stop: 2020-10-30T00:00:00Z}",
								Start: ast.Position{
									Column: 293,
									Line:   11,
								},
							},
						},
						Properties: []*ast.Property{&ast.Property{
							BaseNode: ast.BaseNode{
								Errors: nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 321,
										Line:   11,
									},
									File:   "interval_test.flux",
									Source: "start: 2020-10-30T00:00:00Z",
									Start: ast.Position{
										Column: 294,
										Line:   11,
									},
								},
							},
							Key: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Errors: nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 299,
											Line:   11,
										},
										File:   "interval_test.flux",
										Source: "start",
										Start: ast.Position{
											Column: 294,
											Line:   11,
										},
									},
								},
								Name: "start",
							},
							Value: &ast.DateTimeLiteral{
								BaseNode: ast.BaseNode{
									Errors: nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 321,
											Line:   11,
										},
										File:   "interval_test.flux",
										Source: "2020-10-30T00:00:00Z",
										Start: ast.Position{
											Column: 301,
											Line:   11,
										},
									},
								},
								Value: parser.MustParseTime("2020-10-30T00:00:00Z"),
							},
						}, &ast.Property{
							BaseNode: ast.BaseNode{
								Errors: nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 349,
										Line:   11,
									},
									File:   "interval_test.flux",
									Source: "stop: 2020-10-30T00:00:00Z",
									Start: ast.Position{
										Column: 323,
										Line:   11,
									},
								},
							},
							Key: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Errors: nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 327,
											Line:   11,
										},
										File:   "interval_test.flux",
										Source: "stop",
										Start: ast.Position{
											Column: 323,
											Line:   11,
										},
									},
								},
								Name: "stop",
							},
							Value: &ast.DateTimeLiteral{
								BaseNode: ast.BaseNode{
									Errors: nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 349,
											Line:   11,
										},
										File:   "interval_test.flux",
										Source: "2020-10-30T00:00:00Z",
										Start: ast.Position{
											Column: 329,
											Line:   11,
										},
									},
								},
								Value: parser.MustParseTime("2020-10-30T00:00:00Z"),
							},
						}},
						With: nil,
					}, &ast.ObjectExpression{
						BaseNode: ast.BaseNode{
							Errors: nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 409,
									Line:   11,
								},
								File:   "interval_test.flux",
								Source: "{start: 2020-10-30T00:00:00Z, stop: 2020-10-30T00:00:00Z}",
								Start: ast.Position{
									Column: 352,
									Line:   11,
								},
							},
						},
						Properties: []*ast.Property{&ast.Property{
							BaseNode: ast.BaseNode{
								Errors: nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 380,
										Line:   11,
									},
									File:   "interval_test.flux",
									Source: "start: 2020-10-30T00:00:00Z",
									Start: ast.Position{
										Column: 353,
										Line:   11,
									},
								},
							},
							Key: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Errors: nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 358,
											Line:   11,
										},
										File:   "interval_test.flux",
										Source: "start",
										Start: ast.Position{
											Column: 353,
											Line:   11,
										},
									},
								},
								Name: "start",
							},
							Value: &ast.DateTimeLiteral{
								BaseNode: ast.BaseNode{
									Errors: nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 380,
											Line:   11,
										},
										File:   "interval_test.flux",
										Source: "2020-10-30T00:00:00Z",
										Start: ast.Position{
											Column: 360,
											Line:   11,
										},
									},
								},
								Value: parser.MustParseTime("2020-10-30T00:00:00Z"),
							},
						}, &ast.Property{
							BaseNode: ast.BaseNode{
								Errors: nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 408,
										Line:   11,
									},
									File:   "interval_test.flux",
									Source: "stop: 2020-10-30T00:00:00Z",
									Start: ast.Position{
										Column: 382,
										Line:   11,
									},
								},
							},
							Key: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Errors: nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 386,
											Line:   11,
										},
										File:   "interval_test.flux",
										Source: "stop",
										Start: ast.Position{
											Column: 382,
											Line:   11,
										},
									},
								},
								Name: "stop",
							},
							Value: &ast.DateTimeLiteral{
								BaseNode: ast.BaseNode{
									Errors: nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 408,
											Line:   11,
										},
										File:   "interval_test.flux",
										Source: "2020-10-30T00:00:00Z",
										Start: ast.Position{
											Column: 388,
											Line:   11,
										},
									},
								},
								Value: parser.MustParseTime("2020-10-30T00:00:00Z"),
							},
						}},
						With: nil,
					}, &ast.ObjectExpression{
						BaseNode: ast.BaseNode{
							Errors: nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 468,
									Line:   11,
								},
								File:   "interval_test.flux",
								Source: "{start: 2020-10-30T00:00:00Z, stop: 2020-10-30T00:00:00Z}",
								Start: ast.Position{
									Column: 411,
									Line:   11,
								},
							},
						},
						Properties: []*ast.Property{&ast.Property{
							BaseNode: ast.BaseNode{
								Errors: nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 439,
										Line:   11,
									},
									File:   "interval_test.flux",
									Source: "start: 2020-10-30T00:00:00Z",
									Start: ast.Position{
										Column: 412,
										Line:   11,
									},
								},
							},
							Key: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Errors: nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 417,
											Line:   11,
										},
										File:   "interval_test.flux",
										Source: "start",
										Start: ast.Position{
											Column: 412,
											Line:   11,
										},
									},
								},
								Name: "start",
							},
							Value: &ast.DateTimeLiteral{
								BaseNode: ast.BaseNode{
									Errors: nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 439,
											Line:   11,
										},
										File:   "interval_test.flux",
										Source: "2020-10-30T00:00:00Z",
										Start: ast.Position{
											Column: 419,
											Line:   11,
										},
									},
								},
								Value: parser.MustParseTime("2020-10-30T00:00:00Z"),
							},
						}, &ast.Property{
							BaseNode: ast.BaseNode{
								Errors: nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 467,
										Line:   11,
									},
									File:   "interval_test.flux",
									Source: "stop: 2020-10-30T00:00:00Z",
									Start: ast.Position{
										Column: 441,
										Line:   11,
									},
								},
							},
							Key: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Errors: nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 445,
											Line:   11,
										},
										File:   "interval_test.flux",
										Source: "stop",
										Start: ast.Position{
											Column: 441,
											Line:   11,
										},
									},
								},
								Name: "stop",
							},
							Value: &ast.DateTimeLiteral{
								BaseNode: ast.BaseNode{
									Errors: nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 467,
											Line:   11,
										},
										File:   "interval_test.flux",
										Source: "2020-10-30T00:00:00Z",
										Start: ast.Position{
											Column: 447,
											Line:   11,
										},
									},
								},
								Value: parser.MustParseTime("2020-10-30T00:00:00Z"),
							},
						}},
						With: nil,
					}, &ast.ObjectExpression{
						BaseNode: ast.BaseNode{
							Errors: nil,
							Loc: &ast.SourceLocation{
								End: ast.Position{
									Column: 527,
									Line:   11,
								},
								File:   "interval_test.flux",
								Source: "{start: 2020-10-30T00:00:00Z, stop: 2020-10-30T00:00:00Z}",
								Start: ast.Position{
									Column: 470,
									Line:   11,
								},
							},
						},
						Properties: []*ast.Property{&ast.Property{
							BaseNode: ast.BaseNode{
								Errors: nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 498,
										Line:   11,
									},
									File:   "interval_test.flux",
									Source: "start: 2020-10-30T00:00:00Z",
									Start: ast.Position{
										Column: 471,
										Line:   11,
									},
								},
							},
							Key: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Errors: nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 476,
											Line:   11,
										},
										File:   "interval_test.flux",
										Source: "start",
										Start: ast.Position{
											Column: 471,
											Line:   11,
										},
									},
								},
								Name: "start",
							},
							Value: &ast.DateTimeLiteral{
								BaseNode: ast.BaseNode{
									Errors: nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 498,
											Line:   11,
										},
										File:   "interval_test.flux",
										Source: "2020-10-30T00:00:00Z",
										Start: ast.Position{
											Column: 478,
											Line:   11,
										},
									},
								},
								Value: parser.MustParseTime("2020-10-30T00:00:00Z"),
							},
						}, &ast.Property{
							BaseNode: ast.BaseNode{
								Errors: nil,
								Loc: &ast.SourceLocation{
									End: ast.Position{
										Column: 526,
										Line:   11,
									},
									File:   "interval_test.flux",
									Source: "stop: 2020-10-30T00:00:00Z",
									Start: ast.Position{
										Column: 500,
										Line:   11,
									},
								},
							},
							Key: &ast.Identifier{
								BaseNode: ast.BaseNode{
									Errors: nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 504,
											Line:   11,
										},
										File:   "interval_test.flux",
										Source: "stop",
										Start: ast.Position{
											Column: 500,
											Line:   11,
										},
									},
								},
								Name: "stop",
							},
							Value: &ast.DateTimeLiteral{
								BaseNode: ast.BaseNode{
									Errors: nil,
									Loc: &ast.SourceLocation{
										End: ast.Position{
											Column: 526,
											Line:   11,
										},
										File:   "interval_test.flux",
										Source: "2020-10-30T00:00:00Z",
										Start: ast.Position{
											Column: 506,
											Line:   11,
										},
									},
								},
								Value: parser.MustParseTime("2020-10-30T00:00:00Z"),
							},
						}},
						With: nil,
					}},
				},
			},
		}},
		Imports: []*ast.ImportDeclaration{&ast.ImportDeclaration{
			As: nil,
			BaseNode: ast.BaseNode{
				Errors: nil,
				Loc: &ast.SourceLocation{
					End: ast.Position{
						Column: 22,
						Line:   4,
					},
					File:   "interval_test.flux",
					Source: "import \"experimental\"",
					Start: ast.Position{
						Column: 1,
						Line:   4,
					},
				},
			},
			Path: &ast.StringLiteral{
				BaseNode: ast.BaseNode{
					Errors: nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 22,
							Line:   4,
						},
						File:   "interval_test.flux",
						Source: "\"experimental\"",
						Start: ast.Position{
							Column: 8,
							Line:   4,
						},
					},
				},
				Value: "experimental",
			},
		}, &ast.ImportDeclaration{
			As: nil,
			BaseNode: ast.BaseNode{
				Errors: nil,
				Loc: &ast.SourceLocation{
					End: ast.Position{
						Column: 18,
						Line:   5,
					},
					File:   "interval_test.flux",
					Source: "import \"interval\"",
					Start: ast.Position{
						Column: 1,
						Line:   5,
					},
				},
			},
			Path: &ast.StringLiteral{
				BaseNode: ast.BaseNode{
					Errors: nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 18,
							Line:   5,
						},
						File:   "interval_test.flux",
						Source: "\"interval\"",
						Start: ast.Position{
							Column: 8,
							Line:   5,
						},
					},
				},
				Value: "interval",
			},
		}},
		Metadata: "parser-type=rust",
		Name:     "interval_test.flux",
		Package: &ast.PackageClause{
			BaseNode: ast.BaseNode{
				Errors: nil,
				Loc: &ast.SourceLocation{
					End: ast.Position{
						Column: 22,
						Line:   1,
					},
					File:   "interval_test.flux",
					Source: "package interval_test",
					Start: ast.Position{
						Column: 1,
						Line:   1,
					},
				},
			},
			Name: &ast.Identifier{
				BaseNode: ast.BaseNode{
					Errors: nil,
					Loc: &ast.SourceLocation{
						End: ast.Position{
							Column: 22,
							Line:   1,
						},
						File:   "interval_test.flux",
						Source: "interval_test",
						Start: ast.Position{
							Column: 9,
							Line:   1,
						},
					},
				},
				Name: "interval_test",
			},
		},
	}},
	Package: "interval_test",
	Path:    "interval",
}}
